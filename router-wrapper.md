# 小程序路由封装

小程序的页面路径和文件的路径强耦合，像极了早期的Web时代，URL也是和文件路径强关联的。

这样让小程序的早期设计比较简单明了，但是随着开发的深入，暴露了许多明显的问题。因此，对于小程序路由进行封装，可以说是很有必要的。

根据思维模式 “WHY-HOW-WHAT"黄金圈法则，先讲一下WHY，也就是为什么需要封装路由。

## 为什么需要封装

### 路由跳转的路径与文件路径耦合

小程序的路由跳转使用的是真实文件路径，因此若文件的结构发生变化，必会影响到所有的页面的跳转路径。

笔者在实际开发中就遇到这个问题，以小程序分包举例。

小程序的分包是以文件夹为单位的。如果要将一系列的页面拆分成分包，则需要将这些文件移至同个目录之下，因此必然导致路由地址发生变更。如果此时路由跳转均是直接通过文件地址跳转的话，则需要全局改动，工作量不少。

另外，当开发团队比较庞大时（如我所在团队50+前端开发专注一个小程序），不同的业务之间总会有千丝万缕的关系。当其中一个页面地址发生变更时，其他业务跳转到该页面的地址都需要手动变更。若此时通知不及时，或者遗漏了一些地方，导致跳转失败，终会酿成大错。

### 路由传参

目前小程序支持的传参方式，即通过跳转地址的query字符串。

通过query传参的问题，在Web上是经历过了的。在Web上除了query还可以借用`History API`传参，解决了以下问题：

- query的参数长度有限（具体限度是多少还没尝试过），而`History API`则无限制。
- query只能传递可序列化的数据，而`History API`无限制。

由此可以看出，带解决的问题总结如下：

- 路由跳转的地址与文件路径解耦
- 路由之间传参
- 

## 如何封装

借鉴`react-router`封装的思路，可以使用 **命名路由** 的方式解决前文提及的问题：

通过`Map`来映射 **页面ID** 和 **页面地址**，路由跳转时，仅能使用 **页面ID** 进行路由跳转。